//go:build ignore
// Copyright Â© 2025 Scott Wiederhold <s.e.wiederhold@gmail.com>
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

{{define "renderValidators"}}
    {{- if and (ne .Attr.Type "Bool") (ne .Attr.Type "Object") (or (len .Attr.Enum) (len .Attr.StringPatterns) (len .Attr.StringExclude) (ne .Attr.StringMinLength 0) (ne .Attr.StringMaxLength 0) (len .Attr.RequiredWhen) (ne .Attr.Minimum 0) (ne .Attr.Maximum 0))}}
Validators: []validator.{{.Attr.Type}}{
    {{- if and (eq .Attr.Type "List") (or (eq .Attr.ElementType "String") (eq .Attr.ElementType "Int64"))}}
        listvalidator.Value{{.Attr.ElementType}}sAre(
    {{- end}}
    {{- if or (eq .Attr.Type "String") (eq .Attr.ElementType "String")}}
        {{- if len .Attr.Enum}}
    stringvalidator.OneOf({{range .Attr.Enum}}"{{.}}", {{end}}),
        {{- else}}
            {{- if or (ne .Attr.StringMinLength 0) (ne .Attr.StringMaxLength 0)}}
        stringvalidator.LengthBetween({{.Attr.StringMinLength}}, {{.Attr.StringMaxLength}}),
            {{- end}}
            {{- range .Attr.StringPatterns}}
        stringvalidator.RegexMatches(regexp.MustCompile({{quote .}}), "Must match :" + {{quote .}}),
            {{- end}}
            {{- if len .Attr.StringExclude}}
        stringvalidator.NoneOf([]string{ {{range .Attr.StringExclude}}{{quote .}},{{end}} }...),
            {{- end}}
        {{- end}}
    {{- else if or (eq .Attr.Type "Int64") (eq .Attr.ElementType "Int64")}}
        {{- if or (ne .Attr.Minimum 0) (ne .Attr.Maximum 0)}}
            int64validator.Between({{.Attr.Minimum}}, {{.Attr.Maximum}}),
        {{- end}}
    {{- end}}
    {{- if and (eq .Attr.Type "List") (or (eq .Attr.ElementType "String") (eq .Attr.ElementType "Int64"))}}
        ),
    {{- end}}
    {{- if or (len .Attr.RequiredWhen) (len .Attr.IgnoredWhen)}}
        validators.ConditionalRequired{{.Attr.Type}}({{if len .Attr.RequiredWhen}}{{.ValidatorPrefix}}{{.Root.Name}}{{.Attr.Name}}CondVal{{else}}validators.Evaluation{}{{end}}, {{if len .Attr.IgnoredWhen}}{{.ValidatorPrefix}}{{.Root.Name}}{{.Attr.Name}}IgnoreVal{{else}}validators.Evaluation{}{{end}}, {{if len .Attr.Default}}true{{else}}false{{end}}),
    {{- end}}
},
    {{- end}}
{{- end}}

{{define "renderDefault"}}
    {{- if len .Attr.Default}}
        {{- if eq .Attr.Type "Int64"}}
Default:             int64default.StaticInt64({{.Attr.Default}}),
        {{- else if eq .Attr.Type "Bool"}}
Default:             booldefault.StaticBool({{.Attr.Default}}),
        {{- else if eq .Attr.Type "String"}}
Default:             stringdefault.StaticString({{quote .Attr.Default}}),
        {{- end}}
    {{- else if and (eq .Attr.Type "List") (or (eq .Attr.ElementType "String")) (len .Attr.ListDefault)}}
Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{
    {{- range .Attr.ListDefault}}
        types.StringValue({{quote .}}),
    {{- end}}
})),
    {{- end}}
{{- end}}

{{define "renderPlanModifiers"}}
    {{- if or .Attr.Computed (eq .Attr.Name "AppDomain") (eq .Attr.Name "Id")}}
PlanModifiers: []planmodifier.{{.Attr.Type}}{
    {{- if eq .Attr.Name "AppDomain"}}
        modifiers.ImmutableAfterSet(),
    {{- else if eq .Attr.Name "Id"}}
        stringplanmodifier.RequiresReplace(),
    {{- else if .Attr.Computed}}
        {{lower .Attr.Type}}planmodifier.UseStateForUnknown(),
    {{- end}}
},
    {{- end}}
{{- end}}

{{define "renderSchemaAttribute"}}
    {{- if and .Attr.Type (or (not .Attr.WriteOnly) (and .Attr.WriteOnly .IncludeWriteOnly))}}
"{{.Attr.TfName}}": {{.SchemaPrefix}}{{if eq .Attr.Type "Object"}}SingleNested{{else if .IsList}}List{{- if and (ne .Attr.ElementType "String") (ne .Attr.ElementType "Int64")}}Nested{{end}}{{else}}{{.Attr.Type}}{{end}}Attribute{
    MarkdownDescription: {{if not .IsDataSource}}tfutils.NewAttributeDescription({{end}}{{quote .Attr.Description}},{{if not .IsDataSource}} {{quote .Attr.CliAlias}}, {{quote (toTfName .Attr.ReferenceTo)}}){{end}}
    {{- if not .IsDataSource}}
        {{- if len .Attr.Enum -}}
        .AddStringEnum({{range .Attr.Enum}}"{{.}}", {{end}})
        {{- end -}}
        {{- if or (ne .Attr.Minimum 0) (ne .Attr.Maximum 0) -}}
        .AddIntegerRange({{.Attr.Minimum}}, {{.Attr.Maximum}})
        {{- end -}}
        {{- if .Attr.Default -}}
        .AddDefaultValue({{quote .Attr.Default}})
        {{- end -}}
        {{- if len .Attr.RequiredWhen -}}
        .AddRequiredWhen({{.ValidatorPrefix}}{{.Root.Name}}{{.Attr.Name}}CondVal.String())
        {{- end -}}
        {{- if len .Attr.IgnoredWhen -}}
        .AddNotValidWhen({{.ValidatorPrefix}}{{.Root.Name}}{{.Attr.Name}}IgnoreVal.String())
        {{- end -}}
        .String,
    {{- end}}
    {{- if .IsList}}
        {{- if or (eq .Attr.ElementType "String") (eq .Attr.ElementType "Int64")}}
    ElementType:         types.{{.Attr.ElementType}}Type,
        {{- else}}
    NestedObject:        {{.DmTypeCallPrefix}}Get{{.Attr.ElementType}}{{.DmTypeCallSuffix}}(),
        {{- end}}
    {{- end}}
    {{- if and (or (len .Attr.Default) (len .Attr.ListDefault) .Attr.Computed .IsDataSource) (not (and .IsDataSource (eq .Attr.Name "AppDomain") .Root.Singleton))}}
    Computed:            true,
    {{- end}}
    {{- if and .Attr.Sensitive (eq .Attr.ElementType "String")}}
    Sensitive:           true,
    {{- end}}
    {{- if and .Attr.WriteOnly .IncludeWriteOnly}}
    WriteOnly:           true,
    {{- end}}
    {{- if and .IsDataSource (eq .Attr.Name "AppDomain") .Root.Singleton}}
    Required:            true,
    {{- else if .IsResource}}
        {{- if and .Attr.Required (not (or (len .Attr.Default) (len .Attr.ListDefault)))}}
    Required:            true,
        {{- else if not .Attr.Computed}}
    Optional:            true,
        {{- end}}
        {{- template "renderValidators" (dict "Attr" .Attr "ValidatorPrefix" .ValidatorPrefix "Root" .Root )}}
        {{- template "renderDefault" (dict "Attr" .Attr)}}
    {{- end}}
    {{- if not .IsDataSource}}
    {{- template "renderPlanModifiers" (dict "Attr" .Attr)}}
    {{- end}}
},
    {{- else if and .Attr.DmType (or (not .Attr.WriteOnly) (and .Attr.WriteOnly .IncludeWriteOnly))}}
"{{.Attr.TfName}}": {{.DmTypeCallPrefix}}Get{{.Attr.DmType}}{{.DmTypeCallSuffix}}({{quote .Attr.Description}}, {{quote .Attr.CliAlias}}, {{quote (toTfName .Attr.ReferenceTo)}}{{if .IsResource}}, {{if .Attr.Required}}true{{else}}false{{end}}{{end}}),
    {{- end}}
    {{- if and .Attr.WriteOnly .IncludeWriteOnly}}
"{{.Attr.TfName}}_version": {{.SchemaPrefix}}Int64Attribute{
    MarkdownDescription: "Changes to this value trigger an update to `write_only` value.",
    Optional:            true,
    Validators: []validator.Int64{
        validators.ConditionalRequiredInt64(
            validators.Evaluation{
                Evaluation:  "property-value-not-in-list",
                Attribute:   "{{.Attr.TfName}}",
                AttrType:    "String",
                AttrDefault: "",
                Value:       []string{""},
            }, validators.Evaluation{}, false),
    },
    PlanModifiers: []planmodifier.Int64{
        int64planmodifier.UseStateForUnknown(),
    },
},
    {{- end}}
{{- end}}
