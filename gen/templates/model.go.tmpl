//go:build ignore
// Copyright Â© 2025 Scott Wiederhold <s.e.wiederhold@gmail.com>
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// This file is generated "gen/generator.go"
// !!CHANGES TO THIS FILE WILL BE OVERWRITTEN!!

package models

import (
	"context"
    "net/url"
{{- if .UpdateOnly}}
    "path"
{{- end}}
	"regexp"
    "strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
    DataSourceSchema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
    ResourceSchema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
    "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
	"github.com/scottw514/terraform-provider-datapower/internal/provider/actions"
	"github.com/scottw514/terraform-provider-datapower/internal/provider/tfutils"
	"github.com/scottw514/terraform-provider-datapower/internal/provider/validators"
)

{{- $name := .Name}}
type {{.Name}} struct {
{{- range .Attributes}}
    {{- if .Type}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
        {{- if .WriteOnly}}
	{{toGoName .TfName}}Version types.Int64 `tfsdk:"{{.TfName}}_version"`
        {{- end}}
    {{- else if .DmType}}
	{{toGoName .TfName}} *{{.DmType}} `tfsdk:"{{.TfName}}"`
    {{- end}}
{{- end}}
{{- if not .ModelOnly}}
	DependencyActions []*actions.DependencyAction `tfsdk:"dependency_actions"`
{{- end}}
}

{{- if .WriteOnlyAttrs}}
type {{.Name}}WO struct {
    {{- range .Attributes}}
        {{- if and .Type (not .WriteOnly)}}
	{{toGoName .TfName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
        {{- else if and .DmType (not .WriteOnly)}}
	{{toGoName .TfName}} *{{.DmType}}{{if .WriteOnlyAttrs}}WO{{end}} `tfsdk:"{{.TfName}}"`
        {{- end}}
    {{- end}}
    {{- if not .ModelOnly}}
	DependencyActions []*actions.DependencyAction `tfsdk:"dependency_actions"`
    {{- end}}
}
{{- end}}

{{$root := .}}
{{- range .Attributes}}
    {{- if and (len .RequiredWhen)}}
var {{$root.Name}}{{.Name}}CondVal = validators.Evaluation{
        {{- range .RequiredWhen}}
    Evaluation: "{{.Evaluation}}",
            {{- if len .Conditions}}
    Conditions: []validators.Evaluation{
                {{- range .Conditions}}
        {
            Evaluation: "{{.Evaluation}}",
                    {{- if len .Conditions}}
            Conditions: []validators.Evaluation{
                        {{- range .Conditions}}
                {
                    Evaluation: "{{.Evaluation}}",
                            {{- if len .Conditions}}
                    Conditions: []validators.Evaluation{
                                {{- range .Conditions}}
                        {
                            Evaluation: "{{.Evaluation}}",
                                    {{- if len .Conditions}}
                            Conditions: []validators.Evaluation{
                                        {{- range .Conditions}}
                                {
                                    Evaluation: "{{.Evaluation}}",
                                    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
                                    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
                                    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                                            {{- if .AttrPath}}
                                    AttrPath: {{quote .AttrPath}},
                                            {{- end}}
                                    Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                                },
                                        {{- end}}
                            },
                                    {{- else if not (strContains .Evaluation "logical")}}
                            Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
                            AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
                            AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                                        {{- if .AttrPath}}
                            AttrPath: {{quote .AttrPath}},
                                        {{- end}}
                            Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                                    {{- end}}
                        },
                                {{- end}}
                    },
                            {{- else if not (strContains .Evaluation "logical")}}
                    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
                    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
                    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                                {{- if .AttrPath}}
                    AttrPath: {{quote .AttrPath}},
                                {{- end}}
                    Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                            {{- end}}
                },
                        {{- end}}
            },
                    {{- else if not (strContains .Evaluation "logical")}}
            Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
            AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
            AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                        {{- if .AttrPath}}
            AttrPath: {{quote .AttrPath}},
                        {{- end}}
            Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                    {{- end}}
        },
                {{- end}}
    },
            {{- else if not (strContains .Evaluation "logical")}}
    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                {{- if .AttrPath}}
    AttrPath: {{quote .AttrPath}},
                {{- end}}
    Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
            {{- end}}
        {{- end}}
}
    {{- end}}
{{- end}}

{{- range .Attributes}}
    {{- if and (len .IgnoredWhen)}}
var {{$root.Name}}{{.Name}}IgnoreVal = validators.Evaluation{
        {{- range .IgnoredWhen}}
    Evaluation: "{{.Evaluation}}",
            {{- if len .Conditions}}
    Conditions: []validators.Evaluation{
                {{- range .Conditions}}
        {
            Evaluation: "{{.Evaluation}}",
                    {{- if len .Conditions}}
            Conditions: []validators.Evaluation{
                        {{- range .Conditions}}
                {
                    Evaluation: "{{.Evaluation}}",
                            {{- if len .Conditions}}
                    Conditions: []validators.Evaluation{
                                {{- range .Conditions}}
                        {
                            Evaluation: "{{.Evaluation}}",
                                    {{- if len .Conditions}}
                            Conditions: []validators.Evaluation{
                                        {{- range .Conditions}}
                                {
                                    Evaluation: "{{.Evaluation}}",
                                    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
                                    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
                                    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                                            {{- if .AttrPath}}
                                    AttrPath: {{quote .AttrPath}},
                                            {{- end}}
                                    Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                                },
                                        {{- end}}
                            },
                                    {{- else if not (strContains .Evaluation "logical")}}
                            Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
                            AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
                            AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                                        {{- if .AttrPath}}
                            AttrPath: {{quote .AttrPath}},
                                        {{- end}}
                            Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                                    {{- end}}
                        },
                                {{- end}}
                    },
                            {{- else if not (strContains .Evaluation "logical")}}
                    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
                    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
                    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                                {{- if .AttrPath}}
                    AttrPath: {{quote .AttrPath}},
                                {{- end}}
                    Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                            {{- end}}
                },
                        {{- end}}
            },
                    {{- else if not (strContains .Evaluation "logical")}}
            Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
            AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
            AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                        {{- if .AttrPath}}
            AttrPath: {{quote .AttrPath}},
                        {{- end}}
            Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
                    {{- end}}
        },
                {{- end}}
    },
            {{- else if not (strContains .Evaluation "logical")}}
    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $root.Attributes .Attribute}}{{end}}",
    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $root.Attributes .Attribute}}{{end}}",
    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $root.Attributes .Attribute)}}{{end}},
                {{- if .AttrPath}}
    AttrPath: {{quote .AttrPath}},
                {{- end}}
    Value : []string{ {{range .Value}}{{quote .}}, {{end}} },
            {{- end}}
        {{- end}}
}
    {{- end}}
{{- end}}

var {{.Name}}ObjectType = map[string]attr.Type{
{{- range .Attributes}}
    {{- if or (eq .Type "String") (eq .Type "Int64") (eq .Type "Bool")}}
    "{{.TfName}}": types.{{.Type}}Type,
    {{- else if isObjectList .}}
    "{{.TfName}}": types.ListType{ElemType: types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType } } ,
    {{- else if eq .Type "List"}}
    "{{.TfName}}": types.ListType{ElemType: types.{{.ElementType}}Type },
    {{- else}}
    "{{.TfName}}": types.ObjectType{ AttrTypes: {{.DmType}}ObjectType },
    {{- end}}
    {{- if .WriteOnly}}
	"{{.TfName}}_version": types.Int64Type,
    {{- end}}
{{- end}}
{{- if not .ModelOnly}}
	"dependency_actions": actions.ActionsListType,
{{- end}}
}

{{- if .WriteOnlyAttrs}}
var {{.Name}}ObjectTypeWO = map[string]attr.Type{
    {{- range .Attributes}}
        {{- if not .WriteOnly}}
            {{- if or (eq .Type "String") (eq .Type "Int64") (eq .Type "Bool")}}
    "{{.TfName}}": types.{{.Type}}Type,
            {{- else if isObjectList .}}
    "{{.TfName}}": types.ListType{ElemType: types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}} } } ,
            {{- else if eq .Type "List"}}
    "{{.TfName}}": types.ListType{ElemType: types.{{.ElementType}}Type },
            {{- else}}
    "{{.TfName}}": types.ObjectType{ AttrTypes: {{.DmType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}} },
            {{- end}}
        {{- end}}
    {{- end}}
    {{- if not .ModelOnly}}
	"dependency_actions": actions.ActionsListType,
    {{- end}}
}
{{- end}}

{{- if .ModelOnly}}
var {{.Name}}ObjectDefault = map[string]attr.Value{
    {{- range .Attributes}}
    "{{.TfName}}": 
        {{- if not (isObject .)}}types.{{.Type}}{{if len .Default}}Value({{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}}),{{else}}Null(),{{end}}
        {{- else}}
    types.ObjectValueMust({{.DmType}}ObjectType, {{.DmType}}ObjectDefault),
        {{- end}}
    {{- end}}
}

    {{- $root := . }}
    {{- range .DataResource}}
        {{- $dataResource := .}}
func Get{{$root.Name}}{{$dataResource}}Schema({{if not $root.ListItem}}description string, cliAlias string, referenceTo string{{if eq $dataResource "Resource"}}, required bool{{end}}{{end}}) {{$dataResource}}Schema.{{if $root.ListItem}}NestedAttributeObject{{else}}SingleNestedAttribute{{end}}{
    var {{$root.Name}}{{$dataResource}}Schema = {{$dataResource}}Schema.{{if $root.ListItem}}NestedAttributeObject{{else}}SingleNestedAttribute{{end}}{
        {{- if and (eq $dataResource "DataSource") (not $root.ListItem)}}
        Computed:            true,
        {{- end}}
        {{- if and (eq $dataResource "Resource") (not $root.ListItem)}}
	    Default: objectdefault.StaticValue(
		    types.ObjectValueMust(
			    {{$root.Name}}ObjectType,
			    {{$root.Name}}ObjectDefault,
		    )),
        {{- end}}
        Attributes: map[string]{{$dataResource}}Schema.Attribute{
        {{- range  $root.Attributes}}
            {{- if and .Type (or (not .WriteOnly) (and .WriteOnly (eq $dataResource "Resource")) )}}
            "{{.TfName}}": {{$dataResource}}Schema.{{if eq .Type "Object"}}SingleNested{{- if ne .ElementType "String"}}Nested{{end}}{{else}}{{.Type}}{{end}}Attribute{
                MarkdownDescription: tfutils.NewAttributeDescription({{quote .Description}}, {{quote .CliAlias}}, {{quote (toTfName .ReferenceTo)}})
                {{- if len .Enum -}}
                    .AddStringEnum({{range .Enum}}"{{.}}", {{end}})
                {{- end -}}
                {{- if or (ne .Minimum 0) (ne .Maximum 0) -}}
                    .AddIntegerRange({{.Minimum}}, {{.Maximum}})
                {{- end -}}
                {{- if .Default -}}
                    .AddDefaultValue({{quote .Default}})
                {{- end -}}
        		{{- if len .RequiredWhen -}}
					.AddRequiredWhen({{$root.Name}}{{.Name}}CondVal.String())
		        {{- end -}}
        		{{- if len .IgnoredWhen -}}
					.AddNotValidWhen({{$root.Name}}{{.Name}}IgnoreVal.String())
		        {{- end -}}
                    .String,
                {{- if or (len .Default) .Computed (eq $dataResource "DataSource")}}
                Computed:            true,
                {{- end}}
                {{- if and .Sensitive (eq .ElementType "String")}}
                Sensitive:            true,
                {{- end}}
                {{- if and .WriteOnly (eq $dataResource "Resource")}}
                WriteOnly:           true,
                {{- end}}
                {{- if eq $dataResource "Resource"}}
                    {{- if and .Required (not (len .Default)) }}
                Required:            true,
                    {{- else}}
                Optional:            true,
                    {{- end}}
                    {{- if and (ne .Type "Bool") (or (len .Enum) (len .StringPatterns) (len .StringExclude) (ne .StringMinLength 0) (ne .StringMaxLength 0) (len .RequiredWhen) (ne .Minimum 0) (ne .Maximum 0))}}
                Validators: []validator.{{.Type}}{
                        {{- if eq .Type "String"}}
                            {{- if len .Enum}}
                    stringvalidator.OneOf({{range .Enum}}"{{.}}", {{end}}),
                            {{- else}}
                                {{- if or (ne .StringMinLength 0) (ne .StringMaxLength 0)}}
                    stringvalidator.LengthBetween({{.StringMinLength}}, {{.StringMaxLength}}),
                                {{- end}}
                                {{- range .StringPatterns}}
                    stringvalidator.RegexMatches(regexp.MustCompile({{quote .}}), "Must match :" + {{quote .}}),
                                {{- end}}
                                {{- if len .StringExclude}}
                    stringvalidator.NoneOf([]string{ {{range .StringExclude}}{{quote .}},{{end}} }...),
                                {{- end}}
                            {{- end}}
                        {{- else if eq .Type "Int64"}}
                            {{- if or (ne .Minimum 0) (ne .Maximum 0)}}
                    int64validator.Between({{.Minimum}}, {{.Maximum}}),
                            {{- end}}
                        {{- end}}
                        {{- if or (len .RequiredWhen) (len .IgnoredWhen)}}
                    validators.ConditionalRequired{{.Type}}({{if len .RequiredWhen}}{{$root.Name}}{{.Name}}CondVal{{else}}validators.Evaluation{}{{end}}, {{if len .IgnoredWhen}}{{$root.Name}}{{.Name}}IgnoreVal{{else}}validators.Evaluation{}{{end}}, {{if len .Default}}true{{else}}false{{end}}),
                        {{- end}}
                },
                    {{- end}}
                    {{- if and (len .Default) (eq .Type "Int64")}}
                Default:             int64default.StaticInt64({{.Default}}),
                    {{- else if and (len .Default) (eq .Type "Bool")}}
                Default:             booldefault.StaticBool({{.Default}}),
                    {{- else if and (len .Default) (eq .Type "String")}}
                Default:             stringdefault.StaticString({{quote .Default}}),
                    {{- end}}
                {{- end}}
                {{- if or .Computed .Internal}}
                PlanModifiers: []planmodifier.{{.Type}}{
                {{lower .Type}}planmodifier.UseStateForUnknown(),
                },
                {{- end}}
            },
            {{- else if and .DmType (or (not .WriteOnly) (and .WriteOnly (eq $dataResource "Resource")) )}}
            "{{.TfName}}": Get{{.DmType}}{{$dataResource}}Schema({{quote .Description}}, {{quote .CliAlias}}, {{quote (toTfName .ReferenceTo)}}{{if eq $dataResource "Resource"}}, {{if .Required}}true{{else}}false{{end}}{{end}}),
            {{- end}}
        	{{- if and .WriteOnly (eq $dataResource "Resource")}}
			"{{.TfName}}_version": {{$dataResource}}Schema.Int64Attribute{
				MarkdownDescription: "Changes to this value trigger an update to `write_only` value.",
                Optional:            true,
				Validators: []validator.Int64{
					validators.ConditionalRequiredInt64(
						validators.Evaluation{
							Evaluation:  "property-value-not-in-list",
							Attribute:   "{{.TfName}}",
							AttrType:    "String",
							AttrDefault: "",
							Value:       []string{""},
						}, validators.Evaluation{}, false),
				},
			},
	        {{- end}}
        {{- end}}
        },
    }

        {{- if not $root.ListItem}}
            {{- if eq $dataResource "Resource"}}
    {{$root.Name}}{{$dataResource}}Schema.MarkdownDescription = tfutils.NewAttributeDescription(description, cliAlias, referenceTo).String
    if required {
       {{$root.Name}}{{$dataResource}}Schema.Required = true
    } else {
        {{$root.Name}}{{$dataResource}}Schema.Optional = true
		{{$root.Name}}{{$dataResource}}Schema.Computed = true
    }
            {{- else}}
    {{$root.Name}}{{$dataResource}}Schema.MarkdownDescription = tfutils.NewAttributeDescription(description, cliAlias, referenceTo).String
            {{- end}}
        {{- end}}
    return {{$root.Name}}{{$dataResource}}Schema
}
    {{- end}}
{{- end}}

{{- if not .ModelOnly}}
func (data {{.Name}}) GetPath() string {
    rest_path := {{quote .RestEndpoint}}
    {{- range .Attributes}}
        {{- if eq .Name "AppDomain"}}
    rest_path = strings.ReplaceAll(rest_path, "{domain}", url.QueryEscape(data.AppDomain.ValueString()))
        {{- end}}
        {{- if eq .Name "Id"}}
    rest_path = strings.ReplaceAll(rest_path, "{name}", url.QueryEscape(data.Id.ValueString()))
        {{- end}}
    {{- end}}
    return rest_path
}
    {{- if .WriteOnlyAttrs}}

func (data {{.Name}}WO) GetPath() string {
    rest_path := {{quote .RestEndpoint}}
    {{- range .Attributes}}
        {{- if eq .Name "AppDomain"}}
    rest_path = strings.ReplaceAll(rest_path, "{domain}", url.QueryEscape(data.AppDomain.ValueString()))
        {{- end}}
        {{- if eq .Name "Id"}}
    rest_path = strings.ReplaceAll(rest_path, "{name}", url.QueryEscape(data.Id.ValueString()))
        {{- end}}
    {{- end}}
    return rest_path
}
    {{- end}}
{{- end}}

func (data {{.Name}}) IsNull() bool {
{{- range .Attributes}}
    {{- if .Type}}
    if !data.{{toGoName .TfName}}.IsNull() {
        return false
    }
    {{- else if .DmType}}
    if data.{{toGoName .TfName}} != nil {
        if !data.{{toGoName .TfName}}.IsNull() {
            return false
        }
    }
    {{- end}}
{{- end}}
	return true
}

{{- if .WriteOnlyAttrs}}
func (data {{.Name}}WO) IsNull() bool {
    {{- range .Attributes}}
        {{- if not .WriteOnly}}
            {{- if .Type}}
    if !data.{{toGoName .TfName}}.IsNull() {
        return false
    }
            {{- else if .DmType}}
    if data.{{toGoName .TfName}} != nil {
        if !data.{{toGoName .TfName}}.IsNull() {
            return false
        }
    }
            {{- end}}
        {{- end}}
    {{- end}}
	return true
}
{{- end}}

func (data {{.Name}}) ToBody(ctx context.Context, pathRoot string{{if .WriteOnlyAttrs}}, config *{{.Name}}{{end}}) string {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
	body := ""
{{- if and .UpdateOnly (ne .Name "Domain")}}
		body, _ = sjson.Set(body, "{{.Name}}.name", path.Base("{{.RestEndpoint}}"))
{{- else if eq .Name "Domain"}}
		body, _ = sjson.Set(body, "{{.Name}}.name", data.AppDomain.ValueString())
{{- end}}
{{$root := .}}
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64") (eq .Type "Bool")}}
            {{- if and (ne .Name "AppDomain")}}
                {{- if .WriteOnly}}
	if !data.{{toGoName .TfName}}.IsNull() || !data.{{toGoName .TfName}}Version.IsNull() {
        if data.{{toGoName .TfName}}.IsNull() && config != nil {
            data.{{toGoName .TfName}} = config.{{toGoName .TfName}}
        }
                {{- else}}
	if !data.{{toGoName .TfName}}.IsNull() {
                {{- end}}
		body, _ = sjson.Set(body, pathRoot+{{.Path}}, {{if eq .Type "Bool"}}tfutils.StringFromBool(data.{{toGoName .TfName}}, {{quote .BoolType}}){{else}}data.{{toGoName .TfName}}.Value{{.Type}}(){{end}})
	}
            {{- end}}
        {{- else if isList .}}
	if !data.{{toGoName .TfName}}.IsNull() {
		var dataValues []{{if isStringList .}}string{{else}}{{.ElementType}}{{end}}
		data.{{toGoName .TfName}}.ElementsAs(ctx, &dataValues, false)
            {{- if .WriteOnlyAttrs}}
		var configValues []{{if isStringList .}}string{{else}}{{.ElementType}}{{end}}
		config.{{toGoName .TfName}}.ElementsAs(ctx, &configValues, false)
            {{- end}}
		for {{if .WriteOnlyAttrs}}idx{{else}}_{{end}}, val := range dataValues {
			body, _ = sjson.Set{{if ne .ElementType "String"}}Raw{{end}}(body, pathRoot+{{.Path}}+".-1", {{if eq .ElementType "String"}}map[string]string{"value": val}{{else}}val.ToBody(ctx, ""{{if .WriteOnlyAttrs}}, &configValues[idx]{{end}}){{end}})
		}
	}
        {{- else if isObject .}}
	if data.{{toGoName .TfName}} != nil {
        if !data.{{toGoName .TfName}}.IsNull() {
    		body, _ = sjson.SetRaw(body, pathRoot+{{.Path}}, data.{{toGoName .TfName}}.ToBody(ctx, ""{{if .WriteOnlyAttrs}}, &config.{{.Name}}{{end}}))
        }
	}
        {{- end}}
    {{- end}}
{{- end}}
	return body
}

func (data *{{.Name}}) FromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64")}}
            {{- if ne .Name "AppDomain"}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists(){{if eq .Type "String"}} && tfutils.ParseStringFromGJSON(value).ValueString() != ""{{end}} {
		data.{{toGoName .TfName}} = {{if eq .Type "String"}}tfutils.ParseStringFromGJSON(value){{else}}types.{{.Type}}Value(value.Int()){{end}}
	} else {
		        {{- if .Default}}
		data.{{toGoName .TfName}} = types.{{.Type}}Value({{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}})
		        {{- else}}
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
		        {{- end}}
	}
            {{- end}}
        {{- else if eq .Type "Bool"}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
		data.{{toGoName .TfName}} = tfutils.BoolFromString(value.String())
	} else {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
        {{- else if isList .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
            {{- if eq .ElementType "String"}}
		data.{{toGoName .TfName}} = tfutils.ParseStringListFromGJSON(value)
            {{- else}}
        l := []{{.ElementType}}{{if .WriteOnlyAttrs}}WO{{end}}{}
        if value := res.Get(`{{.Name}}`); value.Exists() {
            for _, v := range value.Array() {
                item := {{.ElementType}}{{if .WriteOnlyAttrs}}WO{{end}}{}
                item.FromBody(ctx, "", v)
                if !item.IsNull() {
                    l = append(l, item)
                }
            }
        }
        if len(l) > 0 {
            data.{{toGoName .TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}}}, l)
        } else {
            data.{{toGoName .TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}}})
        }
            {{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null({{- if eq .ElementType "String"}}types.StringType{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}} }{{- end}})
	}
        {{- else if isObject .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
        data.{{toGoName .TfName}} = &{{.DmType}}{{if .WriteOnlyAttrs}}WO{{end}}{}
    	data.{{toGoName .TfName}}.FromBody(ctx, "", value)
	} else {
    	data.{{toGoName .TfName}} = nil
	}
        {{- end}}
    {{- end}}
{{- end}}
}

{{- if .WriteOnlyAttrs}}
func (data *{{.Name}}WO) FromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
    {{- range .Attributes}}
        {{- if not .Internal}}
            {{- if not .WriteOnly}}
                {{- if or (eq .Type "String") (eq .Type "Int64")}}
                    {{- if ne .Name "AppDomain"}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists(){{if eq .Type "String"}} && tfutils.ParseStringFromGJSON(value).ValueString() != ""{{end}} {
		data.{{toGoName .TfName}} = {{if eq .Type "String"}}tfutils.ParseStringFromGJSON(value){{else}}types.{{.Type}}Value(value.{{if eq .Type "Int64"}}Int{{else}}{{.Type}}{{end}}()){{end}}
	} else {
		                {{- if .Default}}
		data.{{toGoName .TfName}} = types.{{.Type}}Value({{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}})
		                {{- else}}
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
		                {{- end}}
	}
                    {{- end}}
                {{- else if eq .Type "Bool"}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
		data.{{toGoName .TfName}} = tfutils.BoolFromString(value.String())
	} else {
		data.{{toGoName .TfName}} = types.BoolNull()
	}
                {{- else if isList .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
                    {{- if eq .ElementType "String"}}
		data.{{toGoName .TfName}} = tfutils.ParseStringListFromGJSON(value)
                    {{- else}}
        l := []{{.ElementType}}{{if .WriteOnlyAttrs}}WO{{end}}{}
        if value := res.Get(`{{.Name}}`); value.Exists() {
            for _, v := range value.Array() {
                item := {{.ElementType}}{{if .WriteOnlyAttrs}}WO{{end}}{}
                item.FromBody(ctx, "", v)
                if !item.IsNull() {
                    l = append(l, item)
                }
            }
        }
        if len(l) > 0 {
            data.{{toGoName .TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}}}, l)
        } else {
            data.{{toGoName .TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}}})
        }
                    {{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null({{- if or (eq .ElementType "String") (eq .ElementType "Int64")}}types.{{.ElementType}}Type{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}} }{{- end}})
	}
                {{- else if isObject .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
        data.{{toGoName .TfName}} = &{{.DmType}}{{if .WriteOnlyAttrs}}WO{{end}}{}
    	data.{{toGoName .TfName}}.FromBody(ctx, "", value)
	} else {
    	data.{{toGoName .TfName}} = nil
	}
                {{- end}}
            {{- end}}
        {{- end}}
    {{- end}}
}
{{- end}}

func (data *{{.Name}}) UpdateFromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64") (eq .Type "Bool")}}
            {{- if ne .Name "AppDomain"}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = {{if eq .Type "String"}}tfutils.ParseStringFromGJSON(value){{else if eq .Type "Bool"}}tfutils.BoolFromString(value.String()){{else}}types.{{.Type}}Value(value.{{if eq .Type "Int64"}}Int{{else}}{{.Type}}{{end}}()){{end}}
	} else {{if .Default}}if {{if and (eq .Type "Bool") (eq .Default "true")}}!{{end}}data.{{toGoName .TfName}}.Value{{.Type}}() {{if ne .Type "Bool"}}!= {{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}}{{end}}{{end}} {
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
            {{- end}}
        {{- else if isList .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            {{- if eq .ElementType "String"}}
		data.{{toGoName .TfName}} = tfutils.ParseStringListFromGJSON(value)
            {{- else}}
        l := []{{.ElementType}}{}
        for _, v := range value.Array() {
            item := {{.ElementType}}{}
            item.FromBody(ctx, "", v)
            if !item.IsNull() {
                l = append(l, item)
            }
        }
        if len(l) > 0 {
            data.{{toGoName .TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.ElementType}}ObjectType}, l)
        } else {
            data.{{toGoName .TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.ElementType}}ObjectType})
        }
            {{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null({{- if eq .ElementType "String"}}types.StringType{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType }{{- end}})
	}
        {{- else if isObject .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
		data.{{toGoName .TfName}}.UpdateFromBody(ctx, "", value)
	} else {
		data.{{toGoName .TfName}} = nil
	}
        {{- end}}
    {{- end}}
{{- end}}
}

{{- if updateComputed .Attributes}}
func (data *{{.Name}}) UpdateUnknownFromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64")}}
            {{- if ne .Name "AppDomain"}}
    if data.{{toGoName .TfName}}.IsUnknown() {
        if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            data.{{toGoName .TfName}} = {{if eq .Type "String"}}tfutils.ParseStringFromGJSON(value){{else}}types.{{.Type}}Value(value.{{if eq .Type "Int64"}}Int{{else}}{{.Type}}{{end}}()){{end}}
        } else {{if .Default}}if data.{{toGoName .TfName}}.Value{{.Type}}() != {{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}} {{end}}{
            data.{{toGoName .TfName}} = types.{{.Type}}Null()
        }
    }
            {{- end}}
        {{- else if eq .Type "Bool"}}
    if data.{{toGoName .TfName}}.IsUnknown() {
        if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            data.{{toGoName .TfName}} = tfutils.BoolFromString(value.String())
        } else {
            data.{{toGoName .TfName}} = types.BoolNull()
        }
    }
        {{- else if isList .}}
    if data.{{toGoName .TfName}}.IsUnknown() {
    	if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            {{- if eq .ElementType "String"}}
	    	data.{{toGoName .TfName}} = tfutils.ParseStringListFromGJSON(value)
            {{- else}}
            l := []{{.ElementType}}{}
            if value := res.Get(`{{.Name}}`); value.Exists() {
                for _, v := range value.Array() {
                    item := {{.ElementType}}{}
                    item.FromBody(ctx, "", v)
                    if !item.IsNull() {
                        l = append(l, item)
                    }
                }
            }
            if len(l) > 0 {
                data.{{toGoName .TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.ElementType}}ObjectType}, l)
            } else {
                data.{{toGoName .TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.ElementType}}ObjectType})
            }
            {{- end}}
    	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null({{if eq .ElementType "String"}}types.StringType{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType }{{- end}})
    	}
    }
        {{- else if isObject .}}
    if data.{{toGoName .TfName}} == nil {
        if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
            d := {{.DmType}}{}
            d.UpdateFromBody(ctx, "", value)
            if !d.IsNull() {
                data.{{toGoName .TfName}} = &d
            }
        }
    }
        {{- end}}
    {{- end}}
{{- end}}
}
{{- end}}
