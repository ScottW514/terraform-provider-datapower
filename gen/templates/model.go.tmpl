//go:build ignore
// Copyright Â© 2025 Scott Wiederhold <s.e.wiederhold@gmail.com>
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// This file is generated "gen/generator.go"
// !!CHANGES TO THIS FILE WILL BE OVERWRITTEN!!

package models

import (
	"context"
{{- if .Singleton}}
    "path"
{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
	"github.com/scottw514/terraform-provider-datapower/internal/provider/actions"
	"github.com/scottw514/terraform-provider-datapower/internal/provider/tfutils"
	"github.com/scottw514/terraform-provider-datapower/internal/provider/validators"
{{- if .ModelOnly}}
	"regexp"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
    DataSourceSchema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
    ResourceSchema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
    "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
    "github.com/hashicorp/terraform-plugin-framework/schema/validator"
{{- else}}
    "net/url"
    "strings"
{{- end}}
)

{{define "renderAttribute"}}
    {{- if .Attr.Type}}
        {{toGoName .Attr.TfName}} types.{{.Attr.Type}} `tfsdk:"{{.Attr.TfName}}"`
        {{- if .Attr.WriteOnly}}
            {{toGoName .Attr.TfName}}Version types.Int64 `tfsdk:"{{.Attr.TfName}}_version"`
        {{- end}}
    {{- else if .Attr.DmType}}
        {{toGoName .Attr.TfName}} *{{.Attr.DmType}}{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}} `tfsdk:"{{.Attr.TfName}}"`
    {{- end}}
{{- end}}

type {{.Name}} struct {
    {{- range .Attributes}}
        {{- template "renderAttribute" (dict "Attr" . "IsWO" false)}}
    {{- end}}
    {{- if not .ModelOnly}}
        DependencyActions []*actions.DependencyAction `tfsdk:"dependency_actions"`
    {{- end}}
}

{{- if .WriteOnlyAttrs}}
type {{.Name}}WO struct {
    {{- range .Attributes}}
        {{- if not .WriteOnly}}
            {{- template "renderAttribute" (dict "Attr" . "IsWO" true)}}
        {{- end}}
    {{- end}}
    {{- if not .ModelOnly}}
        DependencyActions []*actions.DependencyAction `tfsdk:"dependency_actions"`
    {{- end}}
}
{{- end}}

{{define "renderCondition"}}
{
    Evaluation: "{{.Evaluation.Evaluation}}",
    {{- if len .Evaluation.Conditions}}
    Conditions: []validators.Evaluation{
        {{- range .Evaluation.Conditions}}
        {{template "renderCondition" (dict "Evaluation" . "Root" $.Root)}}
        {{- end}}
    },
    {{- else if not (strContains .Evaluation.Evaluation "logical")}}
    Attribute: "{{if .Evaluation.AttrTfName}}{{.Evaluation.AttrTfName}}{{else}}{{getAttributeTfName $.Root.Attributes .Evaluation.Attribute}}{{end}}",
    AttrType: "{{if .Evaluation.AttrType}}{{.Evaluation.AttrType}}{{else}}{{getAttributeType $.Root.Attributes .Evaluation.Attribute}}{{end}}",
    AttrDefault: {{if .Evaluation.AttrDefault}}{{quote .Evaluation.AttrDefault}}{{else}}{{quote (getAttributeDefault $.Root.Attributes .Evaluation.Attribute)}}{{end}},
        {{- if .Evaluation.AttrPath}}
    AttrPath: {{quote .Evaluation.AttrPath}},
        {{- end}}
    Value: []string{ {{range .Evaluation.Value}}{{quote .}}, {{end}} },
    {{- end}}
},
{{- end}}

{{$root := .}}
{{- range .Attributes}}
    {{- if and (len .RequiredWhen)}}
        {{block "renderEvaluation" (dict "Evaluations" .RequiredWhen "VarName" (print $root.Name .Name "CondVal") "Root" $root)}}
var {{.VarName}} = validators.Evaluation{
    {{- range .Evaluations}}
    Evaluation: "{{.Evaluation}}",
        {{- if len .Conditions}}
    Conditions: []validators.Evaluation{
        {{- range .Conditions}}
        {{- template "renderCondition" (dict "Evaluation" . "Root" $.Root)}}
        {{- end}}
    },
        {{- else if not (strContains .Evaluation "logical")}}
    Attribute: "{{if .AttrTfName}}{{.AttrTfName}}{{else}}{{getAttributeTfName $.Root.Attributes .Attribute}}{{end}}",
    AttrType: "{{if .AttrType}}{{.AttrType}}{{else}}{{getAttributeType $.Root.Attributes .Attribute}}{{end}}",
    AttrDefault: {{if .AttrDefault}}{{quote .AttrDefault}}{{else}}{{quote (getAttributeDefault $.Root.Attributes .Attribute)}}{{end}},
            {{- if .AttrPath}}
    AttrPath: {{quote .AttrPath}},
            {{- end}}
    Value: []string{ {{range .Value}}{{quote .}}, {{end}} },
        {{- end}}
    {{- end}}
}
        {{end}}
    {{- end}}
    {{- if and (len .IgnoredWhen)}}
        {{template "renderEvaluation" (dict "Evaluations" .IgnoredWhen "VarName" (print $root.Name .Name "IgnoreVal") "Root" $root)}}
    {{- end}}
{{- end}}

{{define "renderTypeMapEntry"}}
    {{- if or (eq .Attr.Type "String") (eq .Attr.Type "Int64") (eq .Attr.Type "Bool")}}
    "{{.Attr.TfName}}": types.{{.Attr.Type}}Type,
    {{- else if .IsObjectList}}
    "{{.Attr.TfName}}": types.ListType{ElemType: types.ObjectType{ AttrTypes: {{.Attr.ElementType}}ObjectType{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}} } } ,
    {{- else if eq .Attr.Type "List"}}
    "{{.Attr.TfName}}": types.ListType{ElemType: types.{{.Attr.ElementType}}Type },
    {{- else}}
    "{{.Attr.TfName}}": types.ObjectType{ AttrTypes: {{.Attr.DmType}}ObjectType{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}} },
    {{- end}}
    {{- if and .Attr.WriteOnly (not .IsWO)}}
        "{{.Attr.TfName}}_version": types.Int64Type,
    {{- end}}
{{- end}}

var {{.Name}}ObjectType = map[string]attr.Type{
    {{- range .Attributes}}
        {{- template "renderTypeMapEntry" (dict "Attr" . "IsObjectList" (isObjectList .) "IsWO" false)}}
    {{- end}}
    {{- if not .ModelOnly}}
        "dependency_actions": actions.ActionsListType,
    {{- end}}
}

{{- if .WriteOnlyAttrs}}
var {{.Name}}ObjectTypeWO = map[string]attr.Type{
    {{- range .Attributes}}
        {{- if not .WriteOnly}}
            {{- template "renderTypeMapEntry" (dict "Attr" . "IsObjectList" (isObjectList .) "IsWO" true)}}
        {{- end}}
    {{- end}}
    {{- if not .ModelOnly}}
        "dependency_actions": actions.ActionsListType,
    {{- end}}
}
{{- end}}

{{- if .ModelOnly}}
var {{.Name}}ObjectDefault = map[string]attr.Value{
    {{- range .Attributes}}
    "{{.TfName}}": 
        {{- if not (isObject .)}}types.{{.Type}}{{if len .Default}}Value({{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}}),{{else}}Null(),{{end}}
        {{- else}}
    types.ObjectValueMust({{.DmType}}ObjectType, {{.DmType}}ObjectDefault),
        {{- end}}
    {{- end}}
}

    {{- $root := . }}
    {{- range .DataResource}}
        {{- $dataResource := .}}
func Get{{$root.Name}}{{$dataResource}}Schema({{if not $root.ListItem}}description string, cliAlias string, referenceTo string{{if eq $dataResource "Resource"}}, required bool{{end}}{{end}}) {{$dataResource}}Schema.{{if $root.ListItem}}NestedAttributeObject{{else}}SingleNestedAttribute{{end}}{
    var {{$root.Name}}{{$dataResource}}Schema = {{$dataResource}}Schema.{{if $root.ListItem}}NestedAttributeObject{{else}}SingleNestedAttribute{{end}}{
        {{- if and (eq $dataResource "DataSource") (not $root.ListItem)}}
        Computed:            true,
        {{- end}}
        {{- if and (eq $dataResource "Resource") (not $root.ListItem)}}
	    Default: objectdefault.StaticValue(
		    types.ObjectValueMust(
			    {{$root.Name}}ObjectType,
			    {{$root.Name}}ObjectDefault,
		    )),
        {{- end}}
        Attributes: map[string]{{$dataResource}}Schema.Attribute{
        {{- range  $root.Attributes}}
            {{- if and .Type (or (not .WriteOnly) (and .WriteOnly (eq $dataResource "Resource")) )}}
            "{{.TfName}}": {{$dataResource}}Schema.{{if eq .Type "Object"}}SingleNested{{- if ne .ElementType "String"}}Nested{{end}}{{else}}{{.Type}}{{end}}Attribute{
                MarkdownDescription: tfutils.NewAttributeDescription({{quote .Description}}, {{quote .CliAlias}}, {{quote (toTfName .ReferenceTo)}})
                {{- if len .Enum -}}
                    .AddStringEnum({{range .Enum}}"{{.}}", {{end}})
                {{- end -}}
                {{- if or (ne .Minimum 0) (ne .Maximum 0) -}}
                    .AddIntegerRange({{.Minimum}}, {{.Maximum}})
                {{- end -}}
                {{- if .Default -}}
                    .AddDefaultValue({{quote .Default}})
                {{- end -}}
        		{{- if len .RequiredWhen -}}
					.AddRequiredWhen({{$root.Name}}{{.Name}}CondVal.String())
		        {{- end -}}
        		{{- if len .IgnoredWhen -}}
					.AddNotValidWhen({{$root.Name}}{{.Name}}IgnoreVal.String())
		        {{- end -}}
                    .String,
                {{- if or (len .Default) .Computed (eq $dataResource "DataSource")}}
                Computed:            true,
                {{- end}}
                {{- if and .Sensitive (eq .ElementType "String")}}
                Sensitive:            true,
                {{- end}}
                {{- if and .WriteOnly (eq $dataResource "Resource")}}
                WriteOnly:           true,
                {{- end}}
                {{- if eq $dataResource "Resource"}}
                    {{- if and .Required (not (len .Default)) }}
                Required:            true,
                    {{- else}}
                Optional:            true,
                    {{- end}}
                    {{- if and (ne .Type "Bool") (or (len .Enum) (len .StringPatterns) (len .StringExclude) (ne .StringMinLength 0) (ne .StringMaxLength 0) (len .RequiredWhen) (ne .Minimum 0) (ne .Maximum 0))}}
                Validators: []validator.{{.Type}}{
                        {{- if eq .Type "String"}}
                            {{- if len .Enum}}
                    stringvalidator.OneOf({{range .Enum}}"{{.}}", {{end}}),
                            {{- else}}
                                {{- if or (ne .StringMinLength 0) (ne .StringMaxLength 0)}}
                    stringvalidator.LengthBetween({{.StringMinLength}}, {{.StringMaxLength}}),
                                {{- end}}
                                {{- range .StringPatterns}}
                    stringvalidator.RegexMatches(regexp.MustCompile({{quote .}}), "Must match :" + {{quote .}}),
                                {{- end}}
                                {{- if len .StringExclude}}
                    stringvalidator.NoneOf([]string{ {{range .StringExclude}}{{quote .}},{{end}} }...),
                                {{- end}}
                            {{- end}}
                        {{- else if eq .Type "Int64"}}
                            {{- if or (ne .Minimum 0) (ne .Maximum 0)}}
                    int64validator.Between({{.Minimum}}, {{.Maximum}}),
                            {{- end}}
                        {{- end}}
                        {{- if or (len .RequiredWhen) (len .IgnoredWhen)}}
                    validators.ConditionalRequired{{.Type}}({{if len .RequiredWhen}}{{$root.Name}}{{.Name}}CondVal{{else}}validators.Evaluation{}{{end}}, {{if len .IgnoredWhen}}{{$root.Name}}{{.Name}}IgnoreVal{{else}}validators.Evaluation{}{{end}}, {{if len .Default}}true{{else}}false{{end}}),
                        {{- end}}
                },
                    {{- end}}
                    {{- if and (len .Default) (eq .Type "Int64")}}
                Default:             int64default.StaticInt64({{.Default}}),
                    {{- else if and (len .Default) (eq .Type "Bool")}}
                Default:             booldefault.StaticBool({{.Default}}),
                    {{- else if and (len .Default) (eq .Type "String")}}
                Default:             stringdefault.StaticString({{quote .Default}}),
                    {{- end}}
                {{- end}}
                {{- if or .Computed .Internal}}
                PlanModifiers: []planmodifier.{{.Type}}{
                {{lower .Type}}planmodifier.UseStateForUnknown(),
                },
                {{- end}}
            },
            {{- else if and .DmType (or (not .WriteOnly) (and .WriteOnly (eq $dataResource "Resource")) )}}
            "{{.TfName}}": Get{{.DmType}}{{$dataResource}}Schema({{quote .Description}}, {{quote .CliAlias}}, {{quote (toTfName .ReferenceTo)}}{{if eq $dataResource "Resource"}}, {{if .Required}}true{{else}}false{{end}}{{end}}),
            {{- end}}
        	{{- if and .WriteOnly (eq $dataResource "Resource")}}
			"{{.TfName}}_version": {{$dataResource}}Schema.Int64Attribute{
				MarkdownDescription: "Changes to this value trigger an update to `write_only` value.",
                Optional:            true,
				Validators: []validator.Int64{
					validators.ConditionalRequiredInt64(
						validators.Evaluation{
							Evaluation:  "property-value-not-in-list",
							Attribute:   "{{.TfName}}",
							AttrType:    "String",
							AttrDefault: "",
							Value:       []string{""},
						}, validators.Evaluation{}, false),
				},
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
	        {{- end}}
        {{- end}}
        },
    }

        {{- if not $root.ListItem}}
            {{- if eq $dataResource "Resource"}}
    {{$root.Name}}{{$dataResource}}Schema.MarkdownDescription = tfutils.NewAttributeDescription(description, cliAlias, referenceTo).String
    if required {
        {{$root.Name}}{{$dataResource}}Schema.Required = true
    } else {
        {{$root.Name}}{{$dataResource}}Schema.Optional = true
        {{$root.Name}}{{$dataResource}}Schema.Computed = true
    }
            {{- else}}
    {{$root.Name}}{{$dataResource}}Schema.MarkdownDescription = tfutils.NewAttributeDescription(description, cliAlias, referenceTo).String
            {{- end}}
        {{- end}}
    return {{$root.Name}}{{$dataResource}}Schema
}
    {{- end}}
{{- end}}

{{define "renderPathReplacements"}}
    rest_path := {{quote .Root.RestEndpoint}}
    {{- range .Root.Attributes}}
        {{- if eq .Name "AppDomain"}}
    rest_path = strings.ReplaceAll(rest_path, "{domain}", url.QueryEscape(data.AppDomain.ValueString()))
        {{- end}}
    {{- end}}
    return rest_path
{{- end}}
{{- if not .ModelOnly}}
func (data {{.Name}}) GetPath() string {
    {{- template "renderPathReplacements" (dict "Root" .)}}
}
    {{- if .WriteOnlyAttrs}}

func (data {{.Name}}WO) GetPath() string {
    {{- template "renderPathReplacements" (dict "Root" .)}}
}
    {{- end}}
{{- end}}

{{define "renderNullCheck"}}
    {{- if .Attr.Type}}
    if !data.{{toGoName .Attr.TfName}}.IsNull() {
        return false
    }
    {{- else if .Attr.DmType}}
    if data.{{toGoName .Attr.TfName}} != nil {
        if !data.{{toGoName .Attr.TfName}}.IsNull() {
            return false
        }
    }
    {{- end}}
{{- end}}

{{define "renderIsNullMethod"}}
func (data {{.StructName}}) IsNull() bool {
    {{- range .Attrs}}
        {{- if or (not $.IsWO) (not .WriteOnly)}}
            {{- template "renderNullCheck" (dict "Attr" .)}}
        {{- end}}
    {{- end}}
    return true
}
{{- end}}

{{- template "renderIsNullMethod" (dict "StructName" .Name "Attrs" .Attributes "IsWO" false)}}

{{- if .WriteOnlyAttrs}}
    {{- template "renderIsNullMethod" (dict "StructName" (print .Name "WO") "Attrs" .Attributes "IsWO" true)}}
{{- end}}

{{- if or .Singleton .DefaultFunction}}
func (data *{{.Name}}) ToDefault() {
    {{- range .Attributes}}
        {{- if and (not .Internal) (not .Computed) (not .WriteOnly) (ne .Name "AppDomain") (ne .Name "id")}}
            {{- if or (eq .Type "String") (eq .Type "Int64")}}
                {{- if .ResetValue}}
    data.{{toGoName .TfName}} = types.{{.Type}}Value({{if eq .Type "String"}}{{quote .ResetValue}}{{else}}{{.ResetValue}}{{end}})
                {{- else if .Default}}
    data.{{toGoName .TfName}} = types.{{.Type}}Value({{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}})
                {{- else}}
    data.{{toGoName .TfName}} = types.{{.Type}}Null()
                {{- end}}
            {{- else if eq .Type "Bool"}}
    data.{{toGoName .TfName}} = types.Bool{{if .Default}}Value({{.Default}}){{else}}Null(){{end}}
            {{- else if isList .}}
    data.{{toGoName .TfName}} = types.{{.Type}}Null({{- if eq .ElementType "String"}}types.StringType{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType{{if .WriteOnlyAttrs}}WO{{end}} }{{- end}})
            {{- else if isObject .}}
    data.{{toGoName .TfName}} = &{{.DmType}}{}
    data.{{toGoName .TfName}}.ToDefault()
            {{- end}}
        {{- end}}
    {{- end}}
}
{{- end}}

func (data {{.Name}}) ToBody(ctx context.Context, pathRoot string{{if .WriteOnlyAttrs}}, config *{{.Name}}{{end}}) string {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
	body := ""
{{- if and .Singleton (ne .Name "Domain")}}
		body, _ = sjson.Set(body, "{{.Name}}.name", path.Base("{{.RestEndpoint}}"))
{{- else if eq .Name "Domain"}}
		body, _ = sjson.Set(body, "{{.Name}}.name", data.AppDomain.ValueString())
{{- end}}
{{$root := .}}
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64") (eq .Type "Bool")}}
            {{- if and (ne .Name "AppDomain")}}
                {{- if .WriteOnly}}
	if !data.{{toGoName .TfName}}.IsNull() || !data.{{toGoName .TfName}}Version.IsNull() {
        if data.{{toGoName .TfName}}.IsNull() && config != nil {
            data.{{toGoName .TfName}} = config.{{toGoName .TfName}}
        }
                {{- else}}
	if !data.{{toGoName .TfName}}.IsNull() {
                {{- end}}
		body, _ = sjson.Set(body, pathRoot+{{.Path}}, {{if eq .Type "Bool"}}tfutils.StringFromBool(data.{{toGoName .TfName}}, {{quote .BoolType}}){{else}}data.{{toGoName .TfName}}.Value{{.Type}}(){{end}})
	}
            {{- end}}
        {{- else if isList .}}
	if !data.{{toGoName .TfName}}.IsNull() {
		var dataValues []{{if isStringList .}}string{{else}}{{.ElementType}}{{end}}
		data.{{toGoName .TfName}}.ElementsAs(ctx, &dataValues, false)
            {{- if .WriteOnlyAttrs}}
		var configValues []{{if isStringList .}}string{{else}}{{.ElementType}}{{end}}
		config.{{toGoName .TfName}}.ElementsAs(ctx, &configValues, false)
            {{- end}}
		for {{if .WriteOnlyAttrs}}idx{{else}}_{{end}}, val := range dataValues {
			body, _ = sjson.Set{{if ne .ElementType "String"}}Raw{{end}}(body, pathRoot+{{.Path}}+".-1", {{if eq .ElementType "String"}}map[string]string{"value": val}{{else}}val.ToBody(ctx, ""{{if .WriteOnlyAttrs}}, &configValues[idx]{{end}}){{end}})
		}
	}
        {{- else if isObject .}}
	if data.{{toGoName .TfName}} != nil {
        if !data.{{toGoName .TfName}}.IsNull() {
    		body, _ = sjson.SetRaw(body, pathRoot+{{.Path}}, data.{{toGoName .TfName}}.ToBody(ctx, ""{{if .WriteOnlyAttrs}}, &config.{{.Name}}{{end}}))
        }
	}
        {{- end}}
    {{- end}}
{{- end}}
	return body
}

{{define "renderFromBodyAttribute"}}
    {{- if not .Attr.Internal}}
        {{- if or (eq .Attr.Type "String") (eq .Attr.Type "Int64")}}
            {{- if ne .Attr.Name "AppDomain"}}
        if value := res.Get(pathRoot+{{.Attr.Path}}); value.Exists(){{if eq .Attr.Type "String"}} && tfutils.ParseStringFromGJSON(value).ValueString() != ""{{end}} {
            data.{{toGoName .Attr.TfName}} = {{if eq .Attr.Type "String"}}tfutils.ParseStringFromGJSON(value){{else}}types.{{.Attr.Type}}Value(value.Int()){{end}}
        } else {
            {{- if .Attr.Default}}
            data.{{toGoName .Attr.TfName}} = types.{{.Attr.Type}}Value({{if eq .Attr.Type "String"}}{{quote .Attr.Default}}{{else}}{{.Attr.Default}}{{end}})
            {{- else}}
            data.{{toGoName .Attr.TfName}} = types.{{.Attr.Type}}Null()
            {{- end}}
        }
            {{- end}}
        {{- else if eq .Attr.Type "Bool"}}
        if value := res.Get(pathRoot+{{.Attr.Path}}); value.Exists() {
            data.{{toGoName .Attr.TfName}} = tfutils.BoolFromString(value.String())
        } else {
            data.{{toGoName .Attr.TfName}} = types.BoolNull()
        }
        {{- else if .IsList}}
        if value := res.Get(pathRoot+{{.Attr.Path}}); value.Exists() {
            {{- if eq .Attr.ElementType "String"}}
            data.{{toGoName .Attr.TfName}} = tfutils.ParseStringListFromGJSON(value)
            {{- else}}
            l := []{{.Attr.ElementType}}{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}}{}
            if value := res.Get(`{{.Attr.Name}}`); value.Exists() {
                for _, v := range value.Array() {
                    item := {{.Attr.ElementType}}{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}}{}
                    item.FromBody(ctx, "", v)
                    if !item.IsNull() {
                        l = append(l, item)
                    }
                }
            }
            if len(l) > 0 {
                data.{{toGoName .Attr.TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.Attr.ElementType}}ObjectType{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}}}, l)
            } else {
                data.{{toGoName .Attr.TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.Attr.ElementType}}ObjectType{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}}})
            }
            {{- end}}
        } else {
            data.{{toGoName .Attr.TfName}} = types.{{.Attr.Type}}Null({{- if or (eq .Attr.ElementType "String") (eq .Attr.ElementType "Int64")}}types.{{.Attr.ElementType}}Type{{- else}}types.ObjectType{ AttrTypes: {{.Attr.ElementType}}ObjectType{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}} }{{- end}})
        }
        {{- else if .IsObject}}
        if value := res.Get(pathRoot+{{.Attr.Path}}); value.Exists() {
            data.{{toGoName .Attr.TfName}} = &{{.Attr.DmType}}{{if and .IsWO .Attr.WriteOnlyAttrs}}WO{{end}}{}
            data.{{toGoName .Attr.TfName}}.FromBody(ctx, "", value)
        } else {
            data.{{toGoName .Attr.TfName}} = nil
        }
        {{- end}}
    {{- end}}
{{- end}}

{{define "renderFromBodyMethod"}}
func (data *{{.StructName}}) FromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
    {{- range .Attrs}}
        {{- if or (not $.IsWO) (not .WriteOnly)}}
            {{- template "renderFromBodyAttribute" (dict "Attr" . "IsList" (isList .) "IsObject" (isObject .) "IsWO" $.IsWO)}}
        {{- end}}
    {{- end}}
}
{{- end}}

{{- template "renderFromBodyMethod" (dict "StructName" .Name "Attrs" .Attributes "IsWO" false)}}

{{- if .WriteOnlyAttrs}}
    {{- template "renderFromBodyMethod" (dict "StructName" (print .Name "WO") "Attrs" .Attributes "IsWO" true)}}
{{- end}}

func (data *{{.Name}}) UpdateFromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64") (eq .Type "Bool")}}
            {{- if ne .Name "AppDomain"}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
		data.{{toGoName .TfName}} = {{if eq .Type "String"}}tfutils.ParseStringFromGJSON(value){{else if eq .Type "Bool"}}tfutils.BoolFromString(value.String()){{else}}types.{{.Type}}Value(value.{{if eq .Type "Int64"}}Int{{else}}{{.Type}}{{end}}()){{end}}
	} else {{if .Default}}if {{if and (eq .Type "Bool") (eq .Default "true")}}!{{end}}data.{{toGoName .TfName}}.Value{{.Type}}() {{if ne .Type "Bool"}}!= {{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}}{{end}}{{end}} {
		data.{{toGoName .TfName}} = types.{{.Type}}Null()
	}
            {{- end}}
        {{- else if isList .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            {{- if eq .ElementType "String"}}
		data.{{toGoName .TfName}} = tfutils.ParseStringListFromGJSON(value)
            {{- else}}
        l := []{{.ElementType}}{}
		e := []{{.ElementType}}{}
		data.{{toGoName .TfName}}.ElementsAs(ctx, &e, false)
		if len(value.Array()) == len(e) {
			for i, v := range value.Array() {
				item := e[i]
				item.UpdateFromBody(ctx, "", v)
				if !item.IsNull() {
					l = append(l, item)
				}
			}
		} else {
			for _, v := range value.Array() {
				item := {{.ElementType}}{}
				item.FromBody(ctx, "", v)
				if !item.IsNull() {
					l = append(l, item)
				}
			}
		}
        if len(l) > 0 {
            data.{{toGoName .TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.ElementType}}ObjectType}, l)
        } else {
            data.{{toGoName .TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.ElementType}}ObjectType})
        }
            {{- end}}
	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null({{- if eq .ElementType "String"}}types.StringType{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType }{{- end}})
	}
        {{- else if isObject .}}
	if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
		data.{{toGoName .TfName}}.UpdateFromBody(ctx, "", value)
	} else {
		data.{{toGoName .TfName}} = nil
	}
        {{- end}}
    {{- end}}
{{- end}}
}

{{- if updateComputed .Attributes}}
func (data *{{.Name}}) UpdateUnknownFromBody(ctx context.Context, pathRoot string, res gjson.Result) {
    if pathRoot != "" {
        pathRoot = pathRoot + "."
    }
{{- range .Attributes}}
    {{- if not .Internal}}
        {{- if or (eq .Type "String") (eq .Type "Int64")}}
            {{- if ne .Name "AppDomain"}}
    if data.{{toGoName .TfName}}.IsUnknown() {
        if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            data.{{toGoName .TfName}} = {{if eq .Type "String"}}tfutils.ParseStringFromGJSON(value){{else}}types.{{.Type}}Value(value.{{if eq .Type "Int64"}}Int{{else}}{{.Type}}{{end}}()){{end}}
        } else {{if .Default}}if data.{{toGoName .TfName}}.Value{{.Type}}() != {{if eq .Type "String"}}{{quote .Default}}{{else}}{{.Default}}{{end}} {{end}}{
            data.{{toGoName .TfName}} = types.{{.Type}}Null()
        }
    }
            {{- end}}
        {{- else if eq .Type "Bool"}}
    if data.{{toGoName .TfName}}.IsUnknown() {
        if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            data.{{toGoName .TfName}} = tfutils.BoolFromString(value.String())
        } else {
            data.{{toGoName .TfName}} = types.BoolNull()
        }
    }
        {{- else if isList .}}
    if data.{{toGoName .TfName}}.IsUnknown() {
    	if value := res.Get(pathRoot+{{.Path}}); value.Exists() && !data.{{toGoName .TfName}}.IsNull() {
            {{- if eq .ElementType "String"}}
	    	data.{{toGoName .TfName}} = tfutils.ParseStringListFromGJSON(value)
            {{- else}}
            l := []{{.ElementType}}{}
            if value := res.Get(`{{.Name}}`); value.Exists() {
                for _, v := range value.Array() {
                    item := {{.ElementType}}{}
                    item.FromBody(ctx, "", v)
                    if !item.IsNull() {
                        l = append(l, item)
                    }
                }
            }
            if len(l) > 0 {
                data.{{toGoName .TfName}}, _ = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{.ElementType}}ObjectType}, l)
            } else {
                data.{{toGoName .TfName}} = types.ListNull(types.ObjectType{AttrTypes: {{.ElementType}}ObjectType})
            }
            {{- end}}
    	} else {
		data.{{toGoName .TfName}} = types.{{.Type}}Null({{if eq .ElementType "String"}}types.StringType{{- else}}types.ObjectType{ AttrTypes: {{.ElementType}}ObjectType }{{- end}})
    	}
    }
        {{- else if isObject .}}
    if data.{{toGoName .TfName}} == nil {
        if value := res.Get(pathRoot+{{.Path}}); value.Exists() {
            d := {{.DmType}}{}
            d.UpdateFromBody(ctx, "", value)
            if !d.IsNull() {
                data.{{toGoName .TfName}} = &d
            }
        }
    }
        {{- end}}
    {{- end}}
{{- end}}
}
{{- end}}
